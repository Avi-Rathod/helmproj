<project name="Tripwires" threads="1" pubsub="auto" heartbeat-interval="1" remove-on-connector-error="true">
  <metadata>
    <meta id="studioUploadedBy">sas</meta>
    <meta id="studioUploaded">1662377196592</meta>
    <meta id="studioModifiedBy">sas</meta>
    <meta id="studioModified">1662562958286</meta>
    <meta id="layout">{"events":{"Acceptlist":{"x":-390,"y":-95},"B":{"x":-415,"y":-55},"CheckAcceptlist":{"x":-390,"y":20},"CheckExclusions":{"x":-160,"y":20},"CheckTripwires":{"x":70,"y":20},"Events":{"x":-620,"y":-95},"Exclusions":{"x":-160,"y":-95},"FilterAcceptlist":{"x":-390,"y":135},"FilterEvents":{"x":-620,"y":135},"FilterExclusions":{"x":-160,"y":135},"GetEmailAlerts":{"x":70,"y":135},"ParseEvents":{"x":-620,"y":20},"SendEmail":{"x":300,"y":135},"ThrottleAlerts":{"x":300,"y":20},"Tripwires":{"x":70,"y":-95},"UpsertAlerts":{"x":300,"y":-95}}}</meta>
  </metadata>
  <properties>
    <property name="RMQHOST"><![CDATA[sas-rabbitmq-server]]></property>
    <property name="RMQPORT"><![CDATA[5672]]></property>
    <property name="RMQSSL"><![CDATA[true]]></property>
    <property name="RMQUSER"/>
    <property name="RMQPASSWORD"/>
    <property name="PGHOST"><![CDATA[sas-crunchy-platform-postgres-primary]]></property>
    <property name="PGPORT"><![CDATA[5432]]></property>
    <property name="PGENCRYPTION"><![CDATA[1]]></property>
    <property name="PGUSER"/>
    <property name="PGPASSWORD"/>
    <property name="PGDATABASE"><![CDATA[SharedServices]]></property>
    <property name="PGINTERVAL"><![CDATA[60]]></property>
    <property name="PGSCHEMASEPARATOR"/>
    <property name="PGSCHEMASUFFIX"/>
    <property name="TENANT"/>
    <property name="ENTITY"><![CDATA[tripwire]]></property>
    <property name="THROTTLE"><![CDATA[10]]></property>
    <property name="ACCEPTLISTGROUP"><![CDATA[tripwireacceptlist]]></property>
    <property name="SMTPHOST"><![CDATA[mailhost]]></property>
    <property name="SMTPPORT"><![CDATA[25]]></property>
    <property name="SSL_CERT_FILE"><![CDATA[/security/trustedcerts.pem]]></property>
  </properties>
  <contqueries>
    <contquery include-singletons="true" name="events">
      <windows>
        <window-source pubsub="true" index="pi_EMPTY" insert-only="true" name="Events">
          <description><![CDATA[Streaming events from users]]></description>
          <schema>
            <fields>
              <field name="index" type="int64" key="true"/>
              <field name="message" type="string"/>
            </fields>
          </schema>
          <connectors>
            <connector class="rmq" name="mq">
              <properties>
                <property name="type"><![CDATA[pub]]></property>
                <property name="acktimer"><![CDATA[1]]></property>
                <property name="ackwindow"><![CDATA[5]]></property>
                <property name="buspersistence"><![CDATA[true]]></property>
                <property name="buspersistencequeue"><![CDATA[sas.sim.tripwires.@TENANT@]]></property>
                <property name="rmqsslcacert"><![CDATA[@SSL_CERT_FILE@]]></property>
                <property name="rmqssl"><![CDATA[@RMQSSL@]]></property>
                <property name="rmquserid"><![CDATA[@RMQUSER@]]></property>
                <property name="rmqpassword"><![CDATA[@RMQPASSWORD@]]></property>
                <property name="rmqhost"><![CDATA[@RMQHOST@]]></property>
                <property name="rmqport"><![CDATA[@RMQPORT@]]></property>
                <property name="rmqexchange"><![CDATA[sas.application]]></property>
                <property name="rmqtopic"><![CDATA[application.resource.svi-datahub.*.*.success]]></property>
                <property name="rmqtype"><![CDATA[opaquestring]]></property>
                <property name="urlhostport"><![CDATA[sas.sim.tripwires.esp.@TENANT@]]></property>
              </properties>
            </connector>
          </connectors>
        </window-source>
        <window-source pubsub="true" name="Exclusions">
          <description><![CDATA[Excluded records]]></description>
          <schema>
            <fields>
              <field name="id" type="string" key="true"/>
            </fields>
          </schema>
          <connectors>
            <connector class="db" name="db">
              <properties>
                <property name="type"><![CDATA[pub]]></property>
                <property name="selectstatement"><![CDATA[SELECT DISTINCT(CONCAT(originating_type, ' ', originating_object_id)) AS id FROM fdhdata@PGSCHEMASEPARATOR@@PGSCHEMASUFFIX@.@ENTITY@ WHERE tripwire_status='approved' AND tripwire_type='exclusion' AND expiry_date>NOW()]]></property>
                <property name="publishwithupsert"><![CDATA[true]]></property>
                <property name="repeatinterval"><![CDATA[@PGINTERVAL@]]></property>
                <property name="retryconnection"><![CDATA[true]]></property>
                <property name="scrape"><![CDATA[true]]></property>
                <property name="connectstring"><![CDATA[DSN=PostgreSQL Wire Protocol;EncryptionMethod=@PGENCRYPTION@;Truststore=@SSL_CERT_FILE@;Server=@PGHOST@;Port=@PGPORT@;Database=@PGDATABASE@;Uid=@PGUSER@;Pwd=@PGPASSWORD@]]></property>
              </properties>
            </connector>
          </connectors>
        </window-source>
        <window-lua events="create" index="pi_EMPTY" name="ParseEvents">
          <description><![CDATA[Convert the JSON payload into a tabular format]]></description>
          <schema>
            <fields>
              <field name="event_id" type="string" key="true"/>
              <field name="user" type="string"/>
              <field name="action" type="string"/>
              <field name="type" type="string"/>
              <field name="entity" type="string"/>
              <field name="object" type="string"/>
              <field name="tenant" type="string"/>
              <field name="timestamp" type="string"/>
            </fields>
          </schema>
          <copy/>
          <use><![CDATA[message]]></use>
          <code><![CDATA[function uriPathMatch(uri)
    return string.gmatch(uri, "/([^/]+)")
end
function create(data, context)
    local events = {}
    local count = 0
    local message = esp_parseJson(data.message)

    -- Add an insert event from this message
    function addEvent(entity, object)
        local event = {}
        count = count + 1
        event.event_id = message.id .. "+" .. count
        event.tenant = message.headers and message.headers.__tenant or ""
        event.user = message.user
        event.timestamp = message.timeStamp
        event.action = message.payload.action
        event.entity = entity
        event.object = object
        table.insert(events, event)
    end

    -- Process a potential document URI
    function processDocument(uri)
        local nextPath = uriPathMatch(uri)
        local service = nextPath()
        local controller = nextPath()
        local entity = nextPath()
        local object = nextPath()
        if service == "svi-datahub" and controller == "documents" and entity ~= nil and object ~= nil then
            addEvent(entity, object)
        end
    end

    -- Process a list of references
    function processReferences(references)
        for _, reference in ipairs(references) do
            if reference.uri ~= nil then
                processDocument(reference.uri)
            end
        end
    end

    -- Ensure required fields are available
    if message and message.id and message.user and message.timeStamp and message.payload
        and message.payload.action and type(message.payload.references) == "table" then

        -- Treat searches as reads
        if message.payload.action == "search" then
            message.payload.action = "read"
        end

        -- Only process documents or pages endpoints
        if message.payload.uri then
            local nextPath = uriPathMatch(message.payload.uri)
            local service = nextPath()
            local controller = nextPath()
            if service == "svi-datahub" and (controller == "documents" or controller == "pages") then
                processReferences(message.payload.references)
            end
        end
    end

    -- Return any events of interest
    if count > 0 then
        return(events)
    end
end]]></code>
        </window-lua>
        <window-filter pubsub="true" index="pi_EMPTY" collapse-updates="false" name="FilterEvents">
          <description><![CDATA[Filter by tenant ID and action]]></description>
          <expression><![CDATA[tenant == "@TENANT@" and (action == "read" or action == "update" or action == "delete")]]></expression>
        </window-filter>
        <window-source pubsub="true" name="Tripwires">
          <description><![CDATA[Individual tripwires]]></description>
          <schema>
            <fields>
              <field name="id" type="string" key="true"/>
              <field name="updated" type="string"/>
              <field name="object_type" type="string"/>
              <field name="object_id" type="string"/>
              <field name="generate_email" type="string"/>
              <field name="notification_email" type="string"/>
            </fields>
          </schema>
          <connectors>
            <connector class="db" name="db">
              <properties>
                <property name="type"><![CDATA[pub]]></property>
                <property name="selectstatement"><![CDATA[SELECT @ENTITY@_id as id, to_char(last_updated_at_dttm at time zone 'UTC', 'YYYY-MM-DD"T"HH24:MI:SS.MS') as updated,originating_type as object_type, originating_object_id as object_id, generate_e_mail::char as generate_email, e_mail as notification_email FROM fdhdata@PGSCHEMASEPARATOR@@PGSCHEMASUFFIX@.@ENTITY@ WHERE tripwire_status='approved' AND tripwire_type!='exclusion' AND expiry_date>NOW() AND generate_e_mail=true]]></property>
                <property name="publishwithupsert"><![CDATA[true]]></property>
                <property name="repeatinterval"><![CDATA[@PGINTERVAL@]]></property>
                <property name="retryconnection"><![CDATA[true]]></property>
                <property name="scrape"><![CDATA[true]]></property>
                <property name="connectstring"><![CDATA[DSN=PostgreSQL Wire Protocol;EncryptionMethod=@PGENCRYPTION@;Truststore=@SSL_CERT_FILE@;Server=@PGHOST@;Port=@PGPORT@;Database=@PGDATABASE@;Uid=@PGUSER@;Pwd=@PGPASSWORD@]]></property>
              </properties>
            </connector>
          </connectors>
        </window-source>
        <window-join pubsub="true" collapse-updates="false" output-insert-only="true" name="CheckTripwires">
          <description><![CDATA[Cross reference the event with tripwires]]></description>
          <join type="inner" left-index="pi_EMPTY">
            <conditions>
              <fields left="object" right="object_id"/>
              <fields left="entity" right="object_type"/>
            </conditions>
          </join>
          <output>
            <field-selection name="action" source="l_action"/>
            <field-selection name="user" source="l_user"/>
            <field-selection name="object_type" source="r_object_type"/>
            <field-selection name="object_id" source="r_object_id"/>
            <field-selection name="generate_email" source="r_generate_email"/>
            <field-selection name="notification_email" source="r_notification_email"/>
            <field-selection name="timestamp" source="l_timestamp"/>
          </output>
        </window-join>
        <window-filter pubsub="true" index="pi_EMPTY" name="GetEmailAlerts">
          <description><![CDATA[Select tripwires with email notifications]]></description>
          <expression><![CDATA[generate_email=="t"]]></expression>
        </window-filter>
        <window-source pubsub="true" collapse-updates="false" name="Acceptlist">
          <description><![CDATA[Acceptlisted users]]></description>
          <schema>
            <fields>
              <field name="id" type="string" key="true"/>
            </fields>
          </schema>
          <connectors>
            <connector class="db" name="db">
              <properties>
                <property name="type"><![CDATA[pub]]></property>
                <property name="selectstatement"><![CDATA[SELECT DISTINCT(identity_id) as id FROM identities@PGSCHEMASEPARATOR@@PGSCHEMASUFFIX@.custom_group_membership WHERE group_id='@ACCEPTLISTGROUP@']]></property>
                <property name="publishwithupsert"><![CDATA[true]]></property>
                <property name="repeatinterval"><![CDATA[@PGINTERVAL@]]></property>
                <property name="retryconnection"><![CDATA[true]]></property>
                <property name="scrape"><![CDATA[true]]></property>
                <property name="connectstring"><![CDATA[DSN=PostgreSQL Wire Protocol;EncryptionMethod=@PGENCRYPTION@;Truststore=@SSL_CERT_FILE@;Server=@PGHOST@;Port=@PGPORT@;Database=@PGDATABASE@;Uid=@PGUSER@;Pwd=@PGPASSWORD@]]></property>
              </properties>
            </connector>
          </connectors>
        </window-source>
        <window-join pubsub="true" index="pi_EMPTY" collapse-updates="false" name="CheckAcceptlist">
          <description><![CDATA[Check events against acceptlist]]></description>
          <join type="leftouter" no-regenerates="true" left-index="pi_EMPTY" right-index="pi_HASH">
            <conditions>
              <fields left="user" right="id"/>
            </conditions>
          </join>
          <output>
            <field-expr name="user" type="string"><![CDATA[l_user]]></field-expr>
            <field-expr name="action" type="string"><![CDATA[l_action]]></field-expr>
            <field-expr name="type" type="string"><![CDATA[l_type]]></field-expr>
            <field-expr name="entity" type="string"><![CDATA[l_entity]]></field-expr>
            <field-expr name="object" type="string"><![CDATA[l_object]]></field-expr>
            <field-expr name="acceptlist" type="string"><![CDATA[r_id]]></field-expr>
            <field-expr name="object_and_id" type="string"><![CDATA[l_entity & " " & l_object]]></field-expr>
            <field-expr name="timestamp" type="string"><![CDATA[l_timestamp]]></field-expr>
          </output>
        </window-join>
        <window-filter pubsub="true" index="pi_EMPTY" collapse-updates="false" name="FilterAcceptlist">
          <description><![CDATA[Remove events from users on acceptlist]]></description>
          <expression><![CDATA[ISNULL(acceptlist)]]></expression>
        </window-filter>
        <window-join pubsub="true" index="pi_EMPTY" collapse-updates="false" name="CheckExclusions">
          <description><![CDATA[Check events against exclusions]]></description>
          <join type="leftouter" no-regenerates="true">
            <conditions>
              <fields left="object_and_id" right="id"/>
            </conditions>
          </join>
          <output>
            <field-expr name="user" type="string"><![CDATA[l_user]]></field-expr>
            <field-expr name="action" type="string"><![CDATA[l_action]]></field-expr>
            <field-expr name="type" type="string"><![CDATA[l_type]]></field-expr>
            <field-expr name="entity" type="string"><![CDATA[l_entity]]></field-expr>
            <field-expr name="object" type="string"><![CDATA[l_object]]></field-expr>
            <field-expr name="exclusion" type="string"><![CDATA[r_id]]></field-expr>
            <field-expr name="timestamp" type="string"><![CDATA[l_timestamp]]></field-expr>
          </output>
        </window-join>
        <window-filter pubsub="true" collapse-updates="false" index="pi_EMPTY" name="FilterExclusions">
          <description><![CDATA[Remove events against excluded records]]></description>
          <expression><![CDATA[ISNULL(exclusion)]]></expression>
        </window-filter>
        <window-functional pubsub="true" index="pi_EMPTY" name="UpsertAlerts">
          <description><![CDATA[Convert all inserts into upserts]]></description>
          <schema>
            <fields>
              <field name="id" type="string" key="true"/>
              <field name="user" type="string" key="true"/>
              <field name="action" type="string" key="true"/>
              <field name="object_type" type="string" key="true"/>
              <field name="object_id" type="string" key="true"/>
              <field name="generate_email" type="string"/>
              <field name="notification_email" type="string"/>
              <field name="timestamp" type="string"/>
            </fields>
          </schema>
          <opcode><![CDATA[upsert]]></opcode>
        </window-functional>
        <window-copy pubsub="true" output-insert-only="true" collapse-updates="false" name="ThrottleAlerts">
          <description><![CDATA[Throttle events to prevent batches of duplicate alerts]]></description>
          <retention type="bytime_sliding"><![CDATA[@THROTTLE@ seconds]]></retention>
        </window-copy>
        <window-notification name="SendEmail">
          <description><![CDATA[Send an email notification]]></description>
          <function-context>
            <functions>
              <function name="local_timestamp"><![CDATA[timeString(timeParse(timestamp))]]></function>
            </functions>
          </function-context>
          <smtp host="@SMTPHOST@" port="@SMTPPORT@"/>
          <delivery-channels>
            <email name="Email">
              <email-info>
                <sender><![CDATA[replies-disabled@example.com]]></sender>
                <recipients><![CDATA[$notification_email]]></recipients>
                <subject><![CDATA[Tripwire Notification]]></subject>
                <from><![CDATA[replies-disabled@example.com]]></from>
                <to><![CDATA[$notification_email]]></to>
              </email-info>
              <email-contents>
                <html-content name="Notification"><![CDATA[A tripwire has been activated:<br />
User: $user<br />
Date: $local_timestamp<br />
Action: $action<br />
Object: $object_type/$object_id<br />
Tripwire: $id<br />]]></html-content>
              </email-contents>
            </email>
          </delivery-channels>
        </window-notification>
      </windows>
      <edges>
        <edge source="Events" target="ParseEvents"/>
        <edge source="ParseEvents" target="FilterEvents"/>
        <edge source="CheckTripwires" target="GetEmailAlerts"/>
        <edge source="FilterEvents" target="CheckAcceptlist" role="left"/>
        <edge source="CheckAcceptlist" target="FilterAcceptlist"/>
        <edge source="FilterAcceptlist" target="CheckExclusions" role="left"/>
        <edge source="Exclusions" target="CheckExclusions" role="right"/>
        <edge source="CheckExclusions" target="FilterExclusions"/>
        <edge source="FilterExclusions" target="CheckTripwires" role="left"/>
        <edge source="Tripwires" target="CheckTripwires" role="right"/>
        <edge source="Acceptlist" target="CheckAcceptlist" role="right"/>
        <edge source="GetEmailAlerts" target="UpsertAlerts"/>
        <edge source="UpsertAlerts" target="ThrottleAlerts"/>
        <edge source="ThrottleAlerts" target="SendEmail"/>
      </edges>
    </contquery>
  </contqueries>
  <project-connectors>
    <connector-groups>
      <connector-group name="Database">
        <connector-entry connector="events/Acceptlist/db" state="running"/>
        <connector-entry connector="events/Exclusions/db" state="running"/>
        <connector-entry connector="events/Tripwires/db" state="running"/>
      </connector-group>
      <connector-group name="MessageQueue">
        <connector-entry connector="events/Events/mq" state="finished"/>
      </connector-group>
    </connector-groups>
    <edges>
      <edge source="Database" target="MessageQueue"/>
    </edges>
  </project-connectors>
</project>